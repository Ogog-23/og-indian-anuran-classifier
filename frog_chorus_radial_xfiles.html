<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <title>Western Ghats Frog Chorus – Radial Soundscape</title>
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <style>
    body {
      margin: 0;
      padding: 20px;
      background: #020814;
      color: #e5f5ff;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
    }

    h1 {
      margin-bottom: 0.3rem;
      letter-spacing: 0.04em;
    }

    .subtitle {
      opacity: 0.8;
      margin-bottom: 1.5rem;
      font-size: 0.9rem;
      max-width: 880px;
    }

    /* Upload + guide */
    .upload-layout {
      display: grid;
      grid-template-columns: minmax(0, 3fr) minmax(0, 2fr);
      gap: 20px;
      margin-bottom: 26px;
      align-items: stretch;
    }

    .upload-card,
    .guide-card {
      border-radius: 18px;
      background: #031019;
      box-shadow: 0 14px 35px rgba(0, 0, 0, 0.7);
      padding: 18px 20px;
      display: flex;
      flex-direction: column;
      gap: 10px;
    }

    .upload-title {
      font-size: 0.95rem;
      text-transform: uppercase;
      letter-spacing: 0.12em;
      opacity: 0.8;
      margin-bottom: 4px;
    }

    .upload-box {
      border-radius: 16px;
      border: 1px dashed #1f3b55;
      background: radial-gradient(circle at top, rgba(0, 255, 200, 0.05), transparent 60%);
      padding: 16px;
      text-align: center;
      font-size: 0.86rem;
      margin-top: 4px;
    }

    .upload-box input[type="file"] {
      display: none;
    }

    .upload-helper {
      opacity: 0.75;
      font-size: 0.8rem;
      margin-top: 6px;
    }

    .button-primary {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      padding: 7px 14px;
      border-radius: 999px;
      border: none;
      background: linear-gradient(135deg, #15e0aa, #08b3ff);
      color: #02131f;
      font-size: 0.8rem;
      font-weight: 600;
      cursor: pointer;
    }

    .button-primary:hover {
      filter: brightness(1.05);
    }

    .button-outline {
      padding: 6px 12px;
      border-radius: 999px;
      border: 1px solid #1f3b55;
      background: transparent;
      color: #e5f5ff;
      font-size: 0.8rem;
      cursor: pointer;
    }

    .button-outline:hover {
      background: rgba(16, 49, 78, 0.85);
    }

    .pill {
      font-size: 0.72rem;
      border-radius: 999px;
      padding: 3px 8px;
      background: #072030;
      border: 1px solid #143248;
      display: inline-flex;
      align-items: center;
      gap: 6px;
      margin-top: 4px;
    }

    .pill-dot {
      width: 6px;
      height: 6px;
      border-radius: 999px;
      background: #15e0aa;
    }

    .status-text {
      font-size: 0.8rem;
      opacity: 0.85;
      min-height: 1.2em;
    }

    .status-text.error {
      color: #ff8585;
    }

    .status-text.success {
      color: #b1ffb4;
    }

    .guide-heading {
      font-size: 0.92rem;
      text-transform: uppercase;
      letter-spacing: 0.12em;
      opacity: 0.8;
      margin-bottom: 4px;
    }

    .guide-species-name {
      font-size: 1.1rem;
      font-weight: 600;
      margin-top: 4px;
    }

    .guide-scientific {
      font-size: 0.8rem;
      opacity: 0.8;
      font-style: italic;
    }

    .guide-body {
      font-size: 0.83rem;
      line-height: 1.5;
      opacity: 0.9;
      margin-top: 6px;
    }

    .guide-photo {
      width: 100%;
      border-radius: 14px;
      height: 150px;
      object-fit: cover;
      margin-top: 6px;
      background: #020814;
    }

    .confirm-row {
      display: none;
      gap: 10px;
      align-items: center;
      margin-top: 10px;
      font-size: 0.8rem;
      flex-wrap: wrap;
    }

    /* Main layout + viz styles */
    .layout {
      display: grid;
      grid-template-columns: minmax(0, 3fr) minmax(0, 2.3fr);
      gap: 24px;
      align-items: stretch;
    }

    svg {
      width: 100%;
      height: 520px;
      border-radius: 18px;
      background: radial-gradient(circle at 30% 0%, #0a2038 0, #020814 65%);
      box-shadow: 0 20px 50px rgba(0, 0, 0, 0.75);
    }

    .panel {
      border-radius: 18px;
      background: #040c18;
      box-shadow: 0 14px 35px rgba(0, 0, 0, 0.7);
      padding: 18px 20px;
      display: flex;
      flex-direction: column;
      gap: 10px;
    }

    .panel h2 {
      font-size: 1rem;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      opacity: 0.85;
      margin: 0 0 6px;
    }

    .metric-row {
      display: flex;
      justify-content: space-between;
      font-size: 0.85rem;
      opacity: 0.9;
    }

    .metric-label {
      opacity: 0.7;
    }

    .metric-value {
      font-variant-numeric: tabular-nums;
    }

    .species-list {
      font-size: 0.83rem;
      margin-top: 4px;
    }

    .species-item {
      display: flex;
      align-items: center;
      gap: 8px;
      margin-bottom: 4px;
    }

    .species-swatch {
      width: 10px;
      height: 10px;
      border-radius: 999px;
      flex-shrink: 0;
    }

    .species-name {
      flex-grow: 1;
    }

    .species-bar {
      height: 4px;
      border-radius: 999px;
      background: #0f253c;
      overflow: hidden;
      flex-basis: 45%;
    }

    .species-bar-fill {
      height: 100%;
      border-radius: 999px;
    }

    .story {
      font-size: 0.83rem;
      line-height: 1.5;
      opacity: 0.9;
    }

    .story-label {
      text-transform: uppercase;
      letter-spacing: 0.12em;
      font-size: 0.7rem;
      opacity: 0.7;
      margin-bottom: 2px;
    }

    .story-main {
      color: #b9d8ff;
    }

    .small-label {
      font-size: 0.7rem;
      text-transform: uppercase;
      letter-spacing: 0.16em;
      opacity: 0.6;
    }

    .mono {
      font-family: "JetBrains Mono", ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      font-variant-numeric: tabular-nums;
    }
  </style>
</head>

<body>
  <h1>Western Ghats Frog Chorus – Radial Soundscape</h1>
  <div class="subtitle">
    Citizens can upload frog recordings, get instant species predictions, learn about each frog,
    and confirm what they saw or heard. Validated observations are logged for long-term biodiversity
    monitoring, while the radial view below shows the acoustic activity over the full recording.
  </div>

  <!-- Upload + species guide -->
  <div class="upload-layout">
    <section class="upload-card">
      <div class="upload-title">Upload frog call recording</div>
      <div class="upload-box">
        <p>Drop a frog call recording here or choose a file.</p>
        <button class="button-primary" id="choose-file-btn">Choose audio file</button>
        <input id="audio-input" type="file" accept="audio/*">
        <div class="upload-helper">
          Supports WAV, MP3, FLAC, OGG. Your recording will be analysed by the model and visualised below.
        </div>
      </div>
      <div class="pill">
        <span class="pill-dot"></span>
        <span class="mono" id="predicted-species-pill">No prediction yet</span>
      </div>
      <div class="status-text" id="upload-status"></div>

      <div class="confirm-row" id="confirm-row">
        <span>Are you seeing or hearing this species in your recording?</span>
        <button class="button-outline" id="btn-yes">Yes</button>
        <button class="button-outline" id="btn-no">No / Not sure</button>
      </div>
      <div class="status-text" id="validation-status"></div>
    </section>

    <section class="guide-card">
      <div class="guide-heading">Species guide</div>
      <div class="guide-species-name" id="guide-name">Amboli / Coorg / Knob bush frogs</div>
      <div class="guide-scientific" id="guide-scientific">Upload a recording to see a focused guide.</div>
      <img id="guide-photo" class="guide-photo"
        src="https://images.pexels.com/photos/45853/frog-macro-amphibian-green-45853.jpeg?auto=compress&cs=tinysrgb&w=800"
        alt="Frog photo">
      <div class="guide-body" id="guide-body">
        Once you upload a recording, the model will highlight the most likely bush frog species
        and show a short natural history note here. Confirming the observation adds it to a
        citizen science dataset that can help map breeding sites and calling seasons across
        the Western Ghats.
      </div>
    </section>
  </div>

  <!-- Radial viz + metrics -->
  <div class="layout">
    <svg id="viz"></svg>

    <section class="panel">
      <h2>Frog Chorus Snapshot</h2>

      <div class="metric-row">
        <span class="metric-label">Windows processed</span>
        <span class="metric-value mono" id="m-windows">0</span>
      </div>
      <div class="metric-row">
        <span class="metric-label">Current time in recording</span>
        <span class="metric-value mono" id="m-time">0.0 s</span>
      </div>
      <div class="metric-row">
        <span class="metric-label">Mean confidence (last 60s)</span>
        <span class="metric-value mono" id="m-conf">–</span>
      </div>
      <div class="metric-row">
        <span class="metric-label">Typical peak frequency</span>
        <span class="metric-value mono" id="m-peak">–</span>
      </div>

      <div class="small-label" style="margin-top: 12px;">Species activity in this recording</div>
      <div class="species-list" id="species-list"></div>

      <div style="margin-top: 10px;">
        <div class="story-label">Chorus story</div>
        <div class="story" id="story">
          <span class="story-main">Upload a recording to start the live analysis.</span>
        </div>
      </div>

      <div style="margin-top: 16px;">
        <div class="small-label">Recording playback (your upload)</div>
        <audio id="frog-audio" controls style="width: 100%; margin-top: 6px;"></audio>
      </div>
    </section>
  </div>

  <script>
    // ===== Species guide content =====
    const speciesGuide = {
      "Raven_amboli": {
        displayName: "Amboli bush frog",
        scientific: "Raorchestes bombayensis (Amboli form)",
        text: "Small tree frog associated with moist forests around Amboli. Calls are bright, repeated notes during monsoon nights, often from low shrubs or roadside vegetation.",
        img: "images/raven_amboli.jpg"
      },
      "Raven_coorg": {
        displayName: "Coorg yellow bush frog",
        scientific: "Raorchestes luteolus",
        text: "Endemic to the Western Ghats — Kodagu (Coorg) region. Known for its clear, ringing call produced from bushes and coffee plantations after heavy rain.",
        img: "images/raven_coorg.jpg"
      },
      "Raven_knob": {
        displayName: "Knob-handed bush frog",
        scientific: "Raorchestes tuberohumerus",
        text: "Features a characteristic bony knob near the shoulder. Calls from vegetation near streams; vocalisations are harsher and more rattling compared to other bush frogs. They live in Western Ghats — especially around Kudremukh and nearby shola forests. Often found near streams, clinging to leaves and low branches.",
        img: "images/raven_knob.jpg"
      }
    };



    // ===== DOM refs for upload + guide =====
    const chooseBtn = document.getElementById("choose-file-btn");
    const fileInput = document.getElementById("audio-input");
    const uploadStatusEl = document.getElementById("upload-status");
    const predictedPillEl = document.getElementById("predicted-species-pill");
    const confirmRowEl = document.getElementById("confirm-row");
    const validationStatusEl = document.getElementById("validation-status");

    const guideNameEl = document.getElementById("guide-name");
    const guideSciEl = document.getElementById("guide-scientific");
    const guideBodyEl = document.getElementById("guide-body");
    const guidePhotoEl = document.getElementById("guide-photo");

    const audioEl = document.getElementById("frog-audio");

    let currentRecordingId = null;
    let currentPredictedLabel = null;
    let currentTopProb = null;
    let ws = null;           // WebSocket for viz
    let audioStarted = false;

    // When the user replays the audio (after the first run),
    // restart the WebSocket stream + viz for the same recording.
    if (audioEl) {
      audioEl.addEventListener("play", () => {
        // Only reconnect if:
        //  - we have a recording
        //  - there is no active WebSocket (closed or never opened)
        if (
          currentRecordingId &&
          (!ws || ws.readyState === WebSocket.CLOSED)
        ) {
          connectWebSocketForRecording(currentRecordingId);
        }
      });
    }


    chooseBtn.addEventListener("click", () => fileInput.click());
    fileInput.addEventListener("change", onFileChosen);

    async function onFileChosen(evt) {
      const file = evt.target.files[0];
      if (!file) return;

      // use this file for playback
      if (audioEl) {
        const url = URL.createObjectURL(file);
        audioEl.src = url;
        audioEl.load();
      }

      uploadStatusEl.textContent = "Uploading and analysing recording…";
      uploadStatusEl.className = "status-text";
      predictedPillEl.textContent = "Analysing…";
      validationStatusEl.textContent = "";
      confirmRowEl.style.display = "none";

      const fd = new FormData();
      fd.append("file", file);

      try {
        const res = await fetch("http://localhost:8000/api/upload_frog", {
          method: "POST",
          body: fd
        });
        const data = await res.json();
        if (data.detail || data.error) {
          uploadStatusEl.textContent = data.detail || data.error;
          uploadStatusEl.className = "status-text error";
          predictedPillEl.textContent = "No prediction – error";
          return;
        }

        currentRecordingId = data.recording_id;
        currentPredictedLabel = data.top_label;
        currentTopProb = data.top_prob;

        const probPct = (data.top_prob * 100).toFixed(1) + "%";
        predictedPillEl.textContent = `${data.top_label}  ·  ${probPct}`;
        uploadStatusEl.textContent = "Prediction ready. Please confirm if this matches what you saw or heard.";
        uploadStatusEl.className = "status-text success";

        renderSpeciesGuide(data.top_label);
        confirmRowEl.style.display = "flex";

        // start radial visualisation for this uploaded recording
        if (currentRecordingId) {
          connectWebSocketForRecording(currentRecordingId);
        }
      } catch (err) {
        console.error(err);
        uploadStatusEl.textContent = "Error contacting server. Is server.py running?";
        uploadStatusEl.className = "status-text error";
        predictedPillEl.textContent = "No prediction – server offline";
      }
    }

    function renderSpeciesGuide(label) {
      const info = speciesGuide[label];
      if (!info) return;
      guideNameEl.textContent = info.displayName;
      guideSciEl.textContent = info.scientific;
      guideBodyEl.textContent = info.text;
      guidePhotoEl.src = info.img;
    }

    document.getElementById("btn-yes").addEventListener("click", () => sendValidation("yes"));
    document.getElementById("btn-no").addEventListener("click", () => sendValidation("no"));

    async function sendValidation(answer) {
      if (!currentRecordingId || !currentPredictedLabel) return;

      validationStatusEl.textContent = "Saving your response…";
      validationStatusEl.className = "status-text";

      const payload = {
        recording_id: currentRecordingId,
        species_label: currentPredictedLabel,
        user_answer: answer,
        top_prob: currentTopProb
      };

      try {
        const res = await fetch("http://localhost:8000/api/validate_observation", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(payload)
        });
        const data = await res.json();
        if (data.status === "ok") {
          validationStatusEl.textContent =
            answer === "yes"
              ? "Thank you! Your confirmed observation was saved for the citizen science dataset."
              : "Thank you! Your feedback helps flag uncertain calls for later expert review.";
          validationStatusEl.className = "status-text success";
        } else {
          validationStatusEl.textContent = data.error || data.detail || "Something went wrong while saving.";
          validationStatusEl.className = "status-text error";
        }
      } catch (err) {
        console.error(err);
        validationStatusEl.textContent = "Error talking to server while saving.";
        validationStatusEl.className = "status-text error";
      }
    }

    // ===== Radial visualisation =====
    const speciesOrder = ["Raven_amboli", "Raven_coorg", "Raven_knob"];

    const speciesColor = d3.scaleOrdinal()
      .domain(speciesOrder)
      .range(["#46c7b1", "#a3de73", "#ffd66e"]);

    const svg = d3.select("#viz");
    const width = 960;
    const height = 520;
    const cx = width / 2;
    const cy = height / 2;

    svg.attr("viewBox", `0 0 ${width} ${height}`);
    const gRoot = svg.append("g").attr("transform", `translate(${cx},${cy})`);

    const defs = svg.append("defs");
    const glow = defs.append("filter").attr("id", "glow");
    glow.append("feGaussianBlur")
      .attr("stdDeviation", 3)
      .attr("result", "blur");
    const feMerge = glow.append("feMerge");
    feMerge.append("feMergeNode").attr("in", "blur");
    feMerge.append("feMergeNode").attr("in", "SourceGraphic");

    const baseRadius = 90;
    const ringGap = 42;
    const speciesRadii = {
      "Raven_amboli": { inner: baseRadius, outer: baseRadius + 18 },
      "Raven_coorg": { inner: baseRadius + ringGap, outer: baseRadius + ringGap + 18 },
      "Raven_knob": { inner: baseRadius + 2 * ringGap, outer: baseRadius + 2 * ringGap + 18 }
    };

    const grid = gRoot.append("g").attr("class", "grid");
    [baseRadius - 25, baseRadius + ringGap - 10, baseRadius + 2 * ringGap + 5, baseRadius + 3 * ringGap + 25]
      .forEach(r => {
        grid.append("circle")
          .attr("r", r)
          .attr("fill", "none")
          .attr("stroke", "#132338")
          .attr("stroke-width", 0.6)
          .attr("stroke-dasharray", "2,3");
      });

    const tickCount = 48;
    const ticks = d3.range(tickCount).map(i => (2 * Math.PI * i) / tickCount);
    const tickLayer = gRoot.append("g").attr("class", "ticks");
    ticks.forEach(a => {
      const r0 = baseRadius - 25;
      const r1 = baseRadius + 3 * ringGap + 24;
      tickLayer.append("line")
        .attr("x1", Math.cos(a) * r0)
        .attr("y1", Math.sin(a) * r0)
        .attr("x2", Math.cos(a) * r1)
        .attr("y2", Math.sin(a) * r1)
        .attr("stroke", "#0b1724")
        .attr("stroke-width", 0.6)
        .attr("stroke-opacity", 0.4);
    });

    const centralText = gRoot.append("g")
      .attr("text-anchor", "middle")
      .attr("fill", "#b9d8ff")
      .attr("font-size", 11);

    centralText.append("text")
      .attr("y", -6)
      .attr("letter-spacing", "0.16em")
      .attr("text-transform", "uppercase")
      .attr("opacity", 0.7)
      .text("Frog chorus");

    const centralNow = centralText.append("text")
      .attr("y", 10)
      .attr("class", "mono")
      .text("0.0 s");

    const centralSpecies = centralText.append("text")
      .attr("y", 28)
      .attr("class", "mono")
      .attr("fill", "#ffe69b")
      .text("–");

    let segments = [];
    const windowSize = 60; // seconds
    const speciesSeconds = {};
    const speciesPeakFreqs = {};
    const speciesWindows = {};
    speciesOrder.forEach(s => {
      speciesSeconds[s] = 0;
      speciesPeakFreqs[s] = [];
      speciesWindows[s] = 0;
    });

    let windowsProcessed = 0;
    let meanConfWindow = [];
    let angleScale = d3.scaleLinear().range([0, 2 * Math.PI]);

    const mWindowsEl = document.getElementById("m-windows");
    const mTimeEl = document.getElementById("m-time");
    const mConfEl = document.getElementById("m-conf");
    const mPeakEl = document.getElementById("m-peak");
    const storyEl = document.getElementById("story");
    const speciesListEl = document.getElementById("species-list");

    function resetRadialState() {
      segments = [];
      windowsProcessed = 0;
      meanConfWindow = [];
      speciesOrder.forEach(s => {
        speciesSeconds[s] = 0;
        speciesPeakFreqs[s] = [];
        speciesWindows[s] = 0;
      });
      mWindowsEl.textContent = "0";
      mTimeEl.textContent = "0.0 s";
      mConfEl.textContent = "–";
      mPeakEl.textContent = "–";
      centralNow.text("0.0 s");
      centralSpecies.text("–").attr("fill", "#ffe69b");
      speciesListEl.innerHTML = "";
    }

    function updateAngleScale() {
      if (!segments.length) return;
      const latestEnd = d3.max(segments, d => d.end_time);
      const minT = Math.max(0, latestEnd - windowSize);
      angleScale.domain([minT, latestEnd]);
    }

    function updateSummary(seg) {
      windowsProcessed += 1;
      const dur = seg.end_time - seg.start_time;
      const conf = seg.top_prob || 0;

      if (speciesSeconds.hasOwnProperty(seg.top_label)) {
        speciesSeconds[seg.top_label] += dur;
        speciesWindows[seg.top_label] += 1;
      }

      meanConfWindow.push(conf);
      if (meanConfWindow.length > 200) meanConfWindow.shift();

      mWindowsEl.textContent = windowsProcessed.toString();
      mTimeEl.textContent = `${seg.end_time.toFixed(1)} s`;
      if (meanConfWindow.length) {
        const avg = meanConfWindow.reduce((a, b) => a + b, 0) / meanConfWindow.length;
        mConfEl.textContent = `${(avg * 100).toFixed(1)} %`;
      } else {
        mConfEl.textContent = "–";
      }

      const entries = Object.entries(speciesSeconds);
      const total = entries.reduce((sum, [, s]) => sum + s, 0);
      if (total > 0) {
        const [topSpecies, topS] = entries.sort((a, b) => b[1] - a[1])[0];
        const share = (topS / total) * 100;
        const windowsOfTop = speciesWindows[topSpecies];

        centralNow.text(seg.end_time.toFixed(1) + " s");
        centralSpecies
          .attr("fill", speciesColor(topSpecies))
          .text(topSpecies);

        storyEl.innerHTML =
          `<span class="story-main">${topSpecies}</span> has been the most active caller so far, ` +
          `contributing about <span class="mono">${share.toFixed(0)}%</span> of the frog chorus ` +
          `across <span class="mono">${windowsOfTop}</span> prediction windows.`;
      }
    }

    function renderSpeciesBars() {
      const entries = speciesOrder.map(s => ({
        species: s,
        seconds: speciesSeconds[s],
        color: speciesColor(s)
      }));
      const total = entries.reduce((sum, e) => sum + e.seconds, 0);
      const maxSec = d3.max(entries, e => e.seconds) || 1;

      speciesListEl.innerHTML = "";

      entries.forEach(e => {
        const item = document.createElement("div");
        item.className = "species-item";

        const swatch = document.createElement("span");
        swatch.className = "species-swatch";
        swatch.style.background = e.color;

        const nameSpan = document.createElement("span");
        nameSpan.className = "species-name mono";
        nameSpan.textContent = e.species;

        const statsSpan = document.createElement("span");
        statsSpan.className = "mono";
        statsSpan.style.fontSize = "0.78rem";
        if (total > 0) {
          const pct = (e.seconds / total) * 100;
          statsSpan.textContent = `${pct.toFixed(0)}% chorus`;
        } else {
          statsSpan.textContent = "–";
        }

        const bar = document.createElement("div");
        bar.className = "species-bar";
        const fill = document.createElement("div");
        fill.className = "species-bar-fill";
        fill.style.background = e.color;
        fill.style.width = `${(e.seconds / maxSec) * 100}%`;
        bar.appendChild(fill);

        item.appendChild(swatch);
        item.appendChild(nameSpan);
        item.appendChild(statsSpan);
        item.appendChild(bar);
        speciesListEl.appendChild(item);
      });
    }

    const arcLayer = gRoot.append("g").attr("class", "arcs");
    const dotLayer = gRoot.append("g").attr("class", "dots");

    function updateViz() {
      if (!segments.length) return;

      updateAngleScale();

      const arcGen = d3.arc().cornerRadius(5);

      const arcs = arcLayer.selectAll("path.arc-seg")
        .data(segments, d => `${d.start_time}-${d.top_label}`);

      arcs.join(
        enter => enter.append("path")
          .attr("class", "arc-seg")
          .attr("fill", d => speciesColor(d.top_label))
          .attr("fill-opacity", d => 0.35 + 0.5 * (d.top_prob || 0))
          .attr("filter", "url(#glow)")
          .attr("d", d => {
            const r = speciesRadii[d.top_label];
            const a0 = angleScale(d.start_time);
            const a1 = angleScale(d.start_time);
            return arcGen({
              innerRadius: r.inner,
              outerRadius: r.outer,
              startAngle: a0,
              endAngle: a1
            });
          })
          .transition().duration(450)
          .attrTween("d", function (d) {
            const r = speciesRadii[d.top_label];
            const start = angleScale(d.start_time);
            const end = angleScale(d.end_time);
            const iEnd = d3.interpolate(start, end);
            return function (t) {
              return arcGen({
                innerRadius: r.inner,
                outerRadius: r.outer,
                startAngle: start,
                endAngle: iEnd(t)
              });
            };
          }),
        update => update
          .transition().duration(350)
          .attr("d", d => {
            const r = speciesRadii[d.top_label];
            const a0 = angleScale(d.start_time);
            const a1 = angleScale(d.end_time);
            return arcGen({
              innerRadius: r.inner,
              outerRadius: r.outer,
              startAngle: a0,
              endAngle: a1
            });
          }),
        exit => exit
          .transition().duration(300)
          .attr("fill-opacity", 0)
          .remove()
      );

      const dotData = segments.map(d => {
        const midT = 0.5 * (d.start_time + d.end_time);
        const a = angleScale(midT);
        const rBand = speciesRadii[d.top_label];
        const rMid = 0.5 * (rBand.inner + rBand.outer);

        const baseR = 3 + 5 * (d.top_prob || 0); // more confident -> bigger dot

        return {
          ...d,
          cx: Math.cos(a) * rMid,
          cy: Math.sin(a) * rMid,
          rDot: baseR
        };
      });

      const dots = dotLayer.selectAll("circle.dot")
        .data(dotData, d => `${d.start_time}-${d.top_label}`);

      dots.join(
        enter => enter.append("circle")
          .attr("class", "dot")
          .attr("cx", d => d.cx)
          .attr("cy", d => d.cy)
          .attr("r", 0)
          .attr("fill", d => speciesColor(d.top_label))
          .attr("fill-opacity", 0)
          .attr("filter", "url(#glow)")
          .transition().duration(300)
          .attr("r", d => d.rDot)
          .attr("fill-opacity", d => 0.4 + 0.5 * (d.top_prob || 0))
          .transition().duration(700)
          .attr("r", d => d.rDot * 0.5)
          .attr("fill-opacity", 0.1),
        update => update
          .transition().duration(300)
          .attr("cx", d => d.cx)
          .attr("cy", d => d.cy),
        exit => exit
          .transition().duration(250)
          .attr("fill-opacity", 0)
          .attr("r", 0)
          .remove()
      );

      renderSpeciesBars();
    }

    // Connect WebSocket for a specific uploaded recording
    function connectWebSocketForRecording(recordingId) {
      if (!recordingId) return;

      if (ws) {
        try { ws.close(); } catch (e) { }
        ws = null;
      }

      resetRadialState();
      storyEl.innerHTML = `<span class="story-main">Streaming your uploaded recording…</span>`;

      const url = `ws://localhost:8000/ws/frogs?recording_id=${encodeURIComponent(recordingId)}`;
      ws = new WebSocket(url);
      audioStarted = false;

      ws.onmessage = event => {
        const seg = JSON.parse(event.data);
        if (seg.error) {
          storyEl.innerHTML = `<span class="story-main">${seg.error}</span>`;
          return;
        }

        // start audio on first segment
        if (!audioStarted && audioEl) {
          audioStarted = true;
          try { audioEl.currentTime = seg.start_time || 0; } catch (e) { }
          audioEl.play().catch(() => { /* user may need to press play */ });
        }

        segments.push(seg);
        const cutoff = seg.end_time - windowSize;
        segments = segments.filter(d => d.end_time >= cutoff);

        updateSummary(seg);
        updateViz();
      };

      ws.onerror = () => {
        storyEl.innerHTML = `<span class="story-main">WebSocket error – check that <span class="mono">server.py</span> is running.</span>`;
      };

      ws.onclose = () => {
        if (audioStarted && audioEl) {
          audioEl.pause();
          audioEl.currentTime = 0;
        }
        audioStarted = false;
      };
    }
  </script>
</body>

</html>